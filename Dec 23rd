748. Shortest Completing Word
Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate. 
Such a word is said to complete the given string licensePlate
Here, for letters we ignore case. For example, "P" on the licensePlate still matches "p" on the word.

It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array. 
Solution:
把licensePlate中的空格和数字用replace替换成"",统计，再统计words中每一个，对比，没什么技巧。
def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        numbers = "1234567890"
        licensePlate = licensePlate.replace(" ", "").lower()
        for i in numbers:
            licensePlate = licensePlate.replace(i, "")
        from collections import Counter
        res = Counter(licensePlate)
        back = ""
        for word in words:
            count = Counter(word)
            match = True
            for key in res.keys():
                if res[key] > count[key]:
                        match = False
            if (not back or len(back)>len(word)) and match:
                back = word
        return back

690. Employee Importance
table有员工id，importance和下级id
Solution:
def getImportance(self, employees: List['Employee'], id: int) -> int:
        employee_dict = {employee.id : employee for employee in employees}
        def sub(id):
            back = []
            for employ in employee_dict[id].subordinates:
                back.append(sub(employ))
            return sum(back) + employee_dict[id].importance
        return sub(id)

953. Verifying an Alien Dictionary
alien的字母表不太一样。按新字母表排序word
Solution:
def isAlienSorted(self, words: List[str], order: str) -> bool:
        dd = {}
        for i in range(len(order)):
            dd[order[i]] = i
        for i in range(len(words)-1):
            minlen = min(len(words[i]), len(words[i+1]))
            flag = 0
            for j in range(minlen):
                if dd[words[i][j]] == dd[words[i+1][j]]:
                    continue
                elif dd[words[i][j]] < dd[words[i+1][j]]:
                    flag = 1
                    break
                else:
                    return False
            if flag == 1:
                continue
            if len(words[i]) > len(words[i+1]):
                return False
        return True

1029. Two City Scheduling
Solution:
def twoCitySchedCost(self, costs: List[List[int]]) -> int:
        N = len(costs)
        diff = [c[0] - c[1] for c in costs]
        indices =  sorted(range(0,N), key=lambda k:diff[k])
        result = 0
        for i in range(int(N/2)):
            result += costs[indices[i]][0]
            result += costs[indices[N-i-1]][1]
        return result

169. Majority Element
返回出现超过n/2次的数
Solution:
def majorityElement(self, nums: List[int]) -> int:
        from collections import Counter
        res = Counter(nums)
        for key in res.keys():
            if res[key]>len(nums)//2:
                return key

1275. Find Winner on a Tic Tac Toe Game
