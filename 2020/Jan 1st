Happy New Year!!!!!
572. Subtree of Another Tree
Solution:
感觉二叉树的题很多都是把逻辑整出来就行，就递归的部分应该是按照什么规则递归的。这里就是对s,t调用函数判断，有3种情况返回True，st相同，t和s的子树相同。
在函数中，如果ss和tt都不存在了，直接返回True，如果只有一个肯定是False，ss和tt点val不相同肯定返回False。（这里有个很奇怪的bug，就是如果不把第一函数的
倒数第一个判断写到or一起的话，就要在判断val相等的时候加try，不然就提示t没有val，except直接返回False，可能or里面某个判断引发了错误会直接跳过去判断下一
个）
def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        if not s:
            return
        if self.isSame(s, t):
            return True
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
    
def isSame(self, ss, tt):
    if not ss and not tt:
        return True
    if not ss and not tt:
        return False
    if ss and not tt:
        return False
    try: 
        if ss.val!=tt.val:
            return False
    except:
        return False
    return self.isSame(ss.left, tt.left) and self.isSame(ss.right, tt.right)
    
819. Most Common Word
Solution:
用re找字母然后小写
def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        words = [token for token in re.findall(r"([a-zA-Z]+)", paragraph.lower())]
        count = {}
        for word in words: 
            if word not in banned: 
                count[word] = count.get(word, 0) + 1
            else: 
                continue

        freq = max(count.values())
        return ''.join([k for k, v in count.items() if v == freq])

558. Quad Tree Intersection
Solution:
(fuxue)
def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if q1.isLeaf:
            return q1 if q1.val else q2
        if q2.isLeaf:
            return q2 if q2.val else q1
        
        q1.topLeft = self.intersect(q1.topLeft, q2.topLeft)
        q1.topRight = self.intersect(q1.topRight, q2.topRight)
        q1.bottomLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)
        q1.bottomRight = self.intersect(q1.bottomRight, q2.bottomRight)
        
        if q1.topLeft.isLeaf and q1.topRight.isLeaf and q1.bottomLeft.isLeaf and q1.bottomRight.isLeaf:
            if q1.topLeft.val == q1.topRight.val == q1.bottomLeft.val == q1.bottomRight.val:
                q1.isLeaf = True
                q1.val = q1.topLeft.val
        return q1

671. Second Minimum Node In a Binary Tree
Solution:
def findSecondMinimumValue(self, root: TreeNode) -> int:
        if not root: 
            return -1
        self.res = float("inf")
        self.min = root.val
        self.search(root)
        return self.res if self.res != float("inf") else -1
    
    def search(self, root):
        if not root:
            return
        self.search(root.left)
        if self.min<root.val<self.res:
            self.res = root.val
        self.search(root.right)
        
405. Convert a Number to Hexadecimal
Solution:
def toHex(self, num: int) -> str:
        dic = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}
        if num == 0:
            return "0"
        if num<0:
            num+=2**32
        if num>0:
            bit = int(math.log(num, 16))+1
            ans = ""
            res = num
            for i in range(bit):
                if i == bit-1:
                    if res in dic.keys():
                        ans += dic[res]
                    else:
                        ans+=str(res)
                    break
                high = int(res//16**(bit-1-i))
                if high in dic.keys():
                    ans += dic[high]
                else:
                    ans+=str(high)
                res = int(num%(16**(bit-1-i)))
        return ans

26. Remove Duplicates from Sorted Array
Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Solution:
def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums)==0:
            return 0
        if len(nums)==1:
            return 1
        flag = nums[0]
        i = 1
        while 1:
            try:
                if nums[i] == flag:
                    del nums[i]
                else:
                    flag = nums[i]
                    i += 1
                
            except:
                break
        return len(nums)+1

345. Reverse Vowels of a String
Write a function that takes a string as input and reverse only the vowels of a string.
Solution:
def reverseVowels(self, s: str) -> str:
        if s == "":
            return ""
        if s == " ":
            return " "
        res = []
        dic = ["a", "e", "i", "o", "u", 'A','E','I','O','U']
        for string in s:
            if string in dic:
                res.append(string)
        revres = res[::-1]
        for i in dic:
            s = s.replace(i, "+")
        flag = 0
        for i in range(len(s)):
            if s[i] == "+":
                if i == len(s)-1:
                    s = s[:i]+revres[flag]
                    break
                else:
                    s = s[:i]+revres[flag]+s[i+1:]
                    flag += 1
        return s

231. Power of Two
Given an integer, write a function to determine if it is a power of two.
Solution:
ASSHOLE.
def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        return math.log(n,2)-int(math.log(n,2))<=0.000000001

38. Count and Say
Solution:
统计重复的字母count+字母本身
def countAndSay(self, n: int) -> str:
        res = "1"
        for i in range(n - 1):
            prev = res[0]
            count = 1
            ans = ""
            for j in range(1, len(res)):
                cur = res[j]
                if cur != prev:
                    ans+=str(count)+str(prev)
                    prev = cur
                    count = 0
                count+=1
            res = ans+str(count)+str(prev)
        return res

724. Find Pivot Index
左边和和后边和相等
Solution:
nmd一开始写超时了。从两头往中间走，只需要走一趟就可以完成，而一直sum的话会用很长时间
def pivotIndex(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return -1
        
        left = 0
        right = sum(nums)
        for idx, num in enumerate(nums):
            right -= num
            if left == right:
                return idx
            left += num
        return -1

482. License Key Formatting
The string is separated into N+1 groups by N dashes.
Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the 
first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash 
inserted between two groups and all lowercase letters should be converted to uppercase.
Solution:
def licenseKeyFormatting(self, S: str, K: int) -> str:
        temp = ""
        ans = []
        for i in range(len(S)-1, -1, -1):
            if i == 0:
                if S[0]!='-':
                    if S[0].islower():
                        aka = S[0].upper()
                    else:
                        aka = S[0]
                    temp+=aka
                    ans.append(temp)
                    break
                elif len(temp)!=0:
                    ans.append(temp)
                    break
                else:
                    break
                
            if S[i]!="-":
                if S[i].islower():
                    aka = S[i].upper()
                else:
                    aka = S[i]
                temp+=aka
                if len(temp)==K:
                    ans.append(temp)
                    temp = ""
        return "-".join(ans)[::-1]

110. Balanced Binary Tree
Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as:
a binary tree in which the left and right subtrees of every node differ in height by no more than 1.
Solution:
def isBalanced(self, root: TreeNode) -> bool:
        return self.maxDepth(root) != -1
        
    def maxDepth(self, root):
        if not root:
            return 0
        
        left = self.maxDepth(root.left)
        right = self.maxDepth(root.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        else:
            return max(left, right) + 1
