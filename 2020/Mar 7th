1268. Search Suggestions System
Solution:
python里sort居然能对字符串作用
def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        ans = []
        temp = products
        for i in range(len(searchWord)):
            prefix = searchWord[:i+1]
            tmp = []
            for j in range(len(temp)):
                if temp[j][:i+1] == prefix:
                    tmp.append(temp[j])
            tmp = sorted(tmp)
            if len(tmp)>3:
                tmp = tmp[:3]
            ans.append(tmp)
            # temp = tmp
        return ans

22. Generate Parentheses
Solution:

347. Top K Frequent Elements
Solution:
(1)56.45%  6.25%
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        if len(nums)==1:
            return nums
        left = 0
        right = len(nums)-1
        dict = {}
        while left<=right:
            tmp1 = nums[left]
            tmp2 = nums[right]
            dict[tmp1] = dict.setdefault(tmp1, 0) + 1
            left += 1
            dict[tmp2] = dict.setdefault(tmp2, 0) + 1
            right -= 1
        new = sorted(dict.items(), key=lambda d: d[1])[::-1]
        ans = []
        for i in range(k):
            ans.append(new[i][0])
(2)
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        freq = {}
        freq_list=[]  
        for num in nums:
            freq[num] = freq.setdefault(num, 0) + 1
                
        for key in freq.keys():
            freq_list.append((-freq[key], key))
        heapq.heapify(freq_list)
        topk = []
        for i in range(0,k):
            topk.append(heapq.heappop(freq_list)[1])
        return topk
        print(new)
        # ans = [new.keys()][:k]
        return ans

1143. Longest Common Subsequence
Solution:
def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        return self.lcs(text1, text2)
        
    def lcs(self, X , Y): 
        # find the length of the strings 
        m = len(X) 
        n = len(Y) 

        # declaring the array for storing the dp values 
        L = [[None]*(n+1) for i in range(m+1)] 

        """Following steps build L[m+1][n+1] in bottom up fashion 
        Note: L[i][j] contains length of LCS of X[0..i-1] 
        and Y[0..j-1]"""
        for i in range(m+1): 
            for j in range(n+1): 
                if i == 0 or j == 0 : 
                    L[i][j] = 0
                elif X[i-1] == Y[j-1]: 
                    L[i][j] = L[i-1][j-1]+1
                else: 
                    L[i][j] = max(L[i-1][j] , L[i][j-1]) 

        # L[m][n] contains the length of LCS of X[0..n-1] & Y[0..m-1] 
        return L[m][n] 

1017. Convert to Base -2
Solution:
解析：待定
def baseNeg2(self, N: int) -> str:
        if N==0:
            return "0"
        ans = ""
        while N!=0:
            num = N & 1
            ans = str(num) + ans
            N = -(N>>1)
        return ans
