1318. Minimum Flips to Make a OR b Equal to c
Solution:
def minFlips(self, a: int, b: int, c: int) -> int:
        res=0
        while any((a,b,c)):
            a0,b0,c0=a&1,b&1,c&1
            if c0!=a0|b0:
                if c0:
                    res+=1
                else:
                    res+=a0+b0
            a>>=1
            b>>=1
            c>>=1
        return res

1306. Jump Game III
)DFS(
def canReach(self, arr: List[int], start: int) -> bool:
        self.res = [0]*len(arr)
        return self.helper(arr, start)
        
def helper(self, arr, start):
    if start<0 or start>=len(arr):
        return False
    if arr[start]==0:
        return True
    if self.res[start]==1:
        return False
    self.res[start]=1
    return self.helper(arr, start-arr[start]) or self.helper(arr, start+arr[start])

931. Minimum Falling Path Sum
Solution:
DP
把每一行加到下一行去，
def minFallingPathSum(self, A: List[List[int]]) -> int:
        for i in range(1, len(A)):
            for j in range(len(A)):
                A[i][j] += min(A[i-1][j-1] if j>0 else math.inf, A[i-1][j], A[i-1][j+1] if j<len(A)-1 else math.inf)
        return min(A[-1])

1344. Angle Between Hands of a Clock
Solution:
不知道这破题意义在哪
def angleClock(self, hour: int, minutes: int) -> float:
        ans = abs((hour%12)*30+float(minutes)*30/60 -minutes*6 )
        return ans if ans<=180 else 360-ans

94. Binary Tree Inorder Traversal
Solution:
def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        # stack
        # stack = collections.deque()
        stack=[(root, False)]
        # stack.extend()
        while stack:
            node, visited = stack.pop()
            if node:
                if visited:
                    res.append(node.val)
                # visited = 1
                else:
                    stack.append((node.right, False))
                    stack.append((node, True))
                    # 3的永远在2后面，所以3
                    stack.append((node.left, False))
        return res
改变else后面就能换不同order

695. Max Area of Island
Solution:
def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        def helper(m,n):
            if 0<=m<rows and 0<=n<cols and grid[m][n]==1:
                temp = 1
                grid[m][n] = 0
                for a, b in directions:
                    
                    temp+=helper(m+a, n+b)
                return temp
            
            return 0
            
        ans = [helper(m,n) for m in range(rows) for n in range(cols) if grid[m][n]==1]
        return max(ans) if len(ans) else 0

1140. Stone Game II
Solution:
(LEE215)
def stoneGameII(self, piles: List[int]) -> int:
        N = len(piles)
        
        for i in range(N-2, -1, -1):
            piles[i] += piles[i+1]
        from functools import lru_cache
        @lru_cache(None)
        def helper(i, m):
            if i+2*m>=N:
                return piles[i]
            return piles[i] - min(helper(i+x, max(m, x)) for x in range(1, 2*m+1))
        return helper(0, 1)
解析: 先把piles每个数改成从当前位置累和到最后的和。min里面是当Alex取了i位置之后，Lee能取i+1到2*m+i位置的。helper得到的是从i开始，m为可选长度
的最大可得到参数。那么选择Lee能得到的最小的和，用A[0]剪掉后就得到了剩下的元素的和。

