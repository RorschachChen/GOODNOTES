1318. Minimum Flips to Make a OR b Equal to c
Solution:
def minFlips(self, a: int, b: int, c: int) -> int:
        res=0
        while any((a,b,c)):
            a0,b0,c0=a&1,b&1,c&1
            if c0!=a0|b0:
                if c0:
                    res+=1
                else:
                    res+=a0+b0
            a>>=1
            b>>=1
            c>>=1
        return res

1306. Jump Game III
)DFS(
def canReach(self, arr: List[int], start: int) -> bool:
        self.res = [0]*len(arr)
        return self.helper(arr, start)
        
def helper(self, arr, start):
    if start<0 or start>=len(arr):
        return False
    if arr[start]==0:
        return True
    if self.res[start]==1:
        return False
    self.res[start]=1
    return self.helper(arr, start-arr[start]) or self.helper(arr, start+arr[start])

931. Minimum Falling Path Sum
Solution:
DP
把每一行加到下一行去，
def minFallingPathSum(self, A: List[List[int]]) -> int:
        for i in range(1, len(A)):
            for j in range(len(A)):
                A[i][j] += min(A[i-1][j-1] if j>0 else math.inf, A[i-1][j], A[i-1][j+1] if j<len(A)-1 else math.inf)
        return min(A[-1])

1344. Angle Between Hands of a Clock
Solution:
不知道这破题意义在哪
def angleClock(self, hour: int, minutes: int) -> float:
        ans = abs((hour%12)*30+float(minutes)*30/60 -minutes*6 )
        return ans if ans<=180 else 360-ans

94. Binary Tree Inorder Traversal
Solution:
def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        # stack
        # stack = collections.deque()
        stack=[(root, False)]
        # stack.extend()
        while stack:
            node, visited = stack.pop()
            if node:
                if visited:
                    res.append(node.val)
                # visited = 1
                else:
                    stack.append((node.right, False))
                    stack.append((node, True))
                    # 3的永远在2后面，所以3
                    stack.append((node.left, False))
        return res
改变else后面就能换不同order

695. Max Area of Island
Solution:
def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        def helper(m,n):
            if 0<=m<rows and 0<=n<cols and grid[m][n]==1:
                temp = 1
                grid[m][n] = 0
                for a, b in directions:
                    
                    temp+=helper(m+a, n+b)
                return temp
            
            return 0
            
        ans = [helper(m,n) for m in range(rows) for n in range(cols) if grid[m][n]==1]
        return max(ans) if len(ans) else 0

1140. Stone Game II
Solution:
(LEE215)
def stoneGameII(self, piles: List[int]) -> int:
        N = len(piles)
        
        for i in range(N-2, -1, -1):
            piles[i] += piles[i+1]
        from functools import lru_cache
        @lru_cache(None)
        def helper(i, m):
            if i+2*m>=N:
                return piles[i]
            return piles[i] - min(helper(i+x, max(m, x)) for x in range(1, 2*m+1))
        return helper(0, 1)
解析: 先把piles每个数改成从当前位置累和到最后的和。min里面是当Alex取了i位置之后，Lee能取i+1到2*m+i位置的。helper得到的是从i开始，m为可选长度
的最大可得到参数。那么选择Lee能得到的最小的和，用A[0]剪掉后就得到了剩下的元素的和。

427. Construct Quad Tree
Solution:
def construct(self, grid: List[List[int]]) -> 'Node':
        N = len(grid)
        node = Node(grid[0][0], 1, None, None, None, None)
        for i in range(N):
            for j in range(N):
                if grid[i][j]!=grid[0][0]:
                    node.isLeaf = 0
                    node.topLeft = self.construct([grid[i][:int(N/2)] for i in range(int(N/2))])
                    node.topRight = self.construct([grid[i][int(N/2):] for i in range(int(N/2))])
                    node.bottomLeft = self.construct([grid[i][:int(N/2)] for i in range(int(N/2), N)])
                    node.bottomRight = self.construct([grid[i][int(N/2):] for i in range(int(N/2), N)])
                    return node
        return node

513. Find Bottom Left Tree Value
Solution:
def findBottomLeftValue(self, root: TreeNode) -> int:
        if not root:
            return 
        res = {}
        stack = collections.deque()
        stack.append(root)
        depth = 0
        while stack:
            length = len(stack)
            for i in range(length):
                node = stack.popleft()
                if depth not in res:
                    res[depth] = [node.val]
                else:
                    res[depth].append(node.val)
                if node.left:
                    stack.append(node.left)
                if node.right:
                    stack.append(node.right)
            depth += 1
        maxdp = max(res.keys())
        print(res)
        return res[maxdp][0]

46. permutations
Solution:
回朔法: 56.83% 100%
分析：需要一个visited数组来查看当前数有么有被访问过，如果没有就一直加下去，知道path的长度和nums一样，说明找到了一组答案，append到res中。然后把倒数
第二的vst恢复为没visited的状态。
def permute(self, nums: List[int]) -> List[List[int]]:
        vst = [0]*len(nums)
        res = []
        def helper(path):
            if len(path) == len(nums):
                res.append(path)
            else:
                for i in range(len(nums)):
                    if not vst[i]:
                        vst[i] = 1
                        helper(path+[nums[i]])
                        vst[i] = 0
        helper([])
        return res
(经典递归)
def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.helper(nums, res, [])
        return res
    
def helper(self, nums, res, path):
        if not nums:
            res.append(path)
        else:
            for i in range(len(nums)):
                self.helper(nums[:i] + nums[i + 1:], res, path + [nums[i]])

1072. Flip Columns For Maximum Number of Equal Rows
Solution:
