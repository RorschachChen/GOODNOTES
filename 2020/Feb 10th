fafa
1111. Maximum Nesting Depth of Two Valid Parentheses Strings
Solution:
这道题不一定要连续的，就是把整个seq分成两部分就行。让A和B的depth相近。
def maxDepthAfterSplit(self, seq: str) -> List[int]:
        """
        :type seq: str
        :rtype: List[int]
        """
        depths = [0, 0]
        ans = []
        
        for se in seq:
            if se == '(':
                if depths[0] > depths[1]:
                    depths[1] += 1
                    ans.append(1)
                else:
                    depths[0] += 1
                    ans.append(0)
            else:
                if depths[0] > depths[1]:
                    depths[0] -= 1
                    ans.append(0)
                else:
                    depths[1] -= 1
                    ans.append(1)
                    
        return ans

979. Distribute Coins in Binary Tree
Analysis:
借鉴的想法。首先是dfs，到叶节点的时候，判断是否需要转移资产，需要则把-1作为资产转移给父节点，多了就把正的多余部分交给父节点。回到上层父节点的时候需要
考虑从左右子节点接受的资产，加上目前父节点自己的资产，然后再判断是否要把资产转移到上层父节点。
Solution:
def distributeCoins(self, root: TreeNode) -> int:
        self.ans = 0
        self.dfs(root)
        return self.ans
        
        
def dfs(self, root: TreeNode) -> int:
    """
    :type root: TreeNode
    :rtype: int
    """

    if not root:
        return 0
    x = self.dfs(root.left) + self.dfs(root.right)
    x += root.val
    self.ans += abs(x - 1) # 向父节点转移次数，每次只能转1
    return x - 1 #自己留1，其余上交

1222. Queens That Can Attack the King
Solution:
8个方向
def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
        directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
        ans = []
        for direction in directions:
            pos = [king[0], king[1]]
            while True:
                pos[0] += direction[0]
                pos[1] += direction[1]
                if pos[0]<0 or pos[0]>7 or pos[1]<0 or pos[1]>7:
                    break
                if pos in queens:
                    ans.append(pos)
                    break
            
        return ans

419. Battleships in a Board
Solution:
（暴力解法）
def countBattleships(self, board: List[List[str]]) -> int:
        """
        :type board: List[List[str]]
        :rtype: int
        """
        if len(board) == 0 or len(board[0]) == 0:
            return 0
        row, col = len(board), len(board[0])
        count = 0
        for i in range(row):
            for j in range(col):
                if board[i][j] == 'X' and (i == 0 or board[i - 1][j] == '.') and (j == 0 or board[i][j - 1] == '.'):
                    count += 1
        return count
（BFS）
“在Python中，数字、字符或者元组等不可变对象类型都属于值传递，而字典dict或者列表list等可变对象类型属于引用传递。”
class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        """
        :type board: List[List[str]]
        :rtype: int
        """
        if len(board) == 0 or len(board[0]) == 0:
            return 0
        self.rows, self.cols = len(board), len(board[0])
        visited = [[False]*self.cols for _ in range(self.rows)]
        res = 0
        for i in range(self.rows):
            for j in range(self.cols):
                if board[i][j] == 'X' and not visited[i][j]:
                    vertical, horizontal = [0], [0]
                    self.dfs(board, visited,  vertical,horizontal, i, j)
                    if vertical[0] == i or horizontal[0] == j:
                        res += 1
        return res
    
    def dfs(self, board, visited,  vertical,horizontal, i, j):
        if i < 0 or i >= self.rows or j < 0 or j >= self.cols or visited[i][j] or board[i][j] == '.':
            return
        vertical[0] = vertical[0] or i 
        horizontal[0] = horizontal[0] or j
        visited[i][j] = True
        self.dfs(board, visited,  vertical,horizontal, i-1, j)
        self.dfs(board, visited,  vertical,horizontal, i+1, j)
        self.dfs(board, visited,  vertical,horizontal, i, j-1)
        self.dfs(board, visited,  vertical,horizontal, i, j+1)
(BFS)
def countBattleships(self, board: List[List[str]]) -> int:
        """
        :type board: List[List[str]]
        :rtype: int
        """
        if len(board) == 0 or len(board[0]) == 0:
            return 0
        self.rows, self.cols = len(board), len(board[0])
        visited = [[False]*self.cols for _ in range(self.rows)]
        
        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]
        
        res = 0
        for i in range(self.rows):
            for j in range(self.cols):
                if board[i][j] == 'X' and not visited[i][j]:
                    res += 1
                    q = [(i, j)]
                    while q:
                        t = q.pop()
                        visited[t[0]][t[1]] = True
                        for direction in directions:
                            x = t[0] + direction[0]
                            y = t[1] + direction[1]
                            if x<0 or x>=self.rows or y<0 or y>=self.cols or visited[x][y] or board[x][y] == '.':
                                continue
                            q.append((x, y))
        return res

1277. Count Square Submatrices with All Ones
Solution:
def countSquares(self, matrix: List[List[int]]) -> int:
        rows, cols = len(matrix), len(matrix[0])
        maxlen = max(rows, cols)
        ans = 0
        dp = [[0]*cols for _ in range(rows)]
        for i in range(rows):
            for j in range(cols):
                dp[i][j] = matrix[i][j]
                if i and j and matrix[i][j]:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                ans += dp[i][j]
        return ans   
解析：
            
            
