“拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了。”

一般回溯的问题有三种：
Find a path to success 有没有解
Find all paths to success 求所有解
Find the best path to success 求最优解

https://segmentfault.com/a/1190000006121957

关于回溯的三种问题，模板略有不同，
第一种，返回值是true/false。
第二种，求个数，设全局counter（self.），返回值是void(self.func()只调用不返回)；求所有解信息，设result，返回值void。
第三种，设个全局变量best，返回值是void。


39. Combination Sum
Solution:
from copy import deepcopy
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self.ans = []
        # if len(candidates)<=1:
        # candidates
        self.path = []
        candidates.sort()
        self.helper(candidates, target, 0)
        return self.ans
    
    def helper(self, candidates, target, level):
        if target==0:
            self.ans.append(deepcopy(self.path))
            return
        for i in range(level, len(candidates)):
            if target-candidates[i]<0:
                break
            self.path.append(candidates[i])
            self.helper(candidates, target-candidates[i], i)
            self.path.pop()

40. Combination Sum II
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        self.ans = []
        self.path = []
        candidates.sort()
        visited = [False]*len(candidates)
        self.helper(candidates, target, 0, visited)
        return self.ans
    
    def helper(self, candidates, target, level, visited):
        if target==0:
            self.ans.append(deepcopy(self.path))
            return
        for i in range(level, len(candidates)):
            if i>level and candidates[i]==candidates[i-1]:
                continue
            关键就是同一层不能用两次，但是下一层可以继续用
            if visited[i]:
                continue
            if target-candidates[i]<0:
                break
            self.path.append(candidates[i])
            visited[i] = True
            self.helper(candidates, target-candidates[i], i+1, visited)
            self.path.pop()
            visited[i] = False
