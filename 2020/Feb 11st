1342. Number of Steps to Reduce a Number to Zero
Solution:
def numberOfSteps (self, num: int) -> int:
        temp = num
        step = 0
        while num!=0:
            num = num//2 if num%2==0 else num-1
            step += 1
        return step

1309. Decrypt String from Alphabet to Integer Mapping
Solution:
def freqAlphabets(self, s: str) -> str:
        """
        :type s: str
        :rtype: str
        """
        ans = ""
        i=0
        while i < len(s):
            if i+2<len(s) and s[i+2] == "#":
                ans +=  chr(int(s[i:i+2])+96)
                i+=3
            else:
                ans += chr(int(s[i])+96)
                i+=1
        return ans
        
537. Complex Number Multiplication
Solution:
def complexNumberMultiply(self, a: str, b: str) -> str:
        a1, a2 = a.split('+')
        b1, b2 = b.split('+')
        real = int(a1)*int(b1) - int(a2.rstrip('i')) * int(b2.rstrip('i'))
        image = int(a1) * int(b2.rstrip('i')) + int(b1) * int(a2.rstrip('i'))
        ans = str(real)
        ans += '+'
        ans += str(image)
        ans += 'i'
        return ans

1195. Fizz Buzz Multithreaded
Solution:
多线程

1310. XOR Queries of a Subarray
Solution:
def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
        prefix = [0]*(len(arr)+1)
        for i in range(len(arr)):
            prefix[i+1] = prefix[i]^arr[i]
            
        return [prefix[L]^prefix[R+1] for [L, R] in queries]
P.S. c = a^b, a = c^b, b = c^a        

1123. Lowest Common Ancestor of Deepest Leaves
Solution:
没配图，光从list看不懂树的结构。。。吃了亏
def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        def getMaxDepth(root: TreeNode) -> int:
            if not root:
                return 0
            return max(getMaxDepth(root.left), getMaxDepth(root.right)) + 1
        
        self.maxDepth = getMaxDepth(root)
        
        def helper(root: TreeNode, depth: int) -> TreeNode:
            if not root:
                return 
            if not root.left and not root.right and depth == self.maxDepth - 1:
                return root
            L = helper(root.left, depth + 1)
            R = helper(root.right, depth + 1)
            if not L:
                return R
            if not R:
                return L
            return root
            

        return helper(root, 0)
解析:先递归得到最大深度。然后就找哪些等于最大深度的叶节点。如果在某深度没找到，就把depth加一，然后去下层找。

951. Flip Equivalent Binary Trees
Solution:
解析：有两种可能。第一种是考虑同一个节点的，两棵树的左子树，要么不换，也就是光判断（左左，右右），另一种是交换了（左右，右左）。判断的条件就是在确认有
子树之后看它们待确认的子树的值是否相等
def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:
        """
        :type : TreeNode, TreeNode
        :rtype : bool
        """
        if not root1 and not root2:
            return True
        if not root1 or not root2:
            return False
        
        if root1.val != root2.val:
            return False
        
        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))
        
感觉
