â€œæ‹¿åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œä½ æ„Ÿè§‰å¦‚æœä¸ç©·ä¸¾ä¸€ä¸‹å°±æ²¡æ³•çŸ¥é“ç­”æ¡ˆï¼Œé‚£å°±å¯ä»¥å¼€å§‹å›æº¯äº†ã€‚â€

ä¸€èˆ¬å›æº¯çš„é—®é¢˜æœ‰ä¸‰ç§ï¼š
Find a path to success æœ‰æ²¡æœ‰è§£
Find all paths to success æ±‚æ‰€æœ‰è§£
Find the best path to success æ±‚æœ€ä¼˜è§£

https://segmentfault.com/a/1190000006121957

å…³äºå›æº¯çš„ä¸‰ç§é—®é¢˜ï¼Œæ¨¡æ¿ç•¥æœ‰ä¸åŒï¼Œ
ç¬¬ä¸€ç§ï¼Œè¿”å›å€¼æ˜¯true/falseã€‚
ç¬¬äºŒç§ï¼Œæ±‚ä¸ªæ•°ï¼Œè®¾å…¨å±€counterï¼ˆself.ï¼‰ï¼Œè¿”å›å€¼æ˜¯void(self.func()åªè°ƒç”¨ä¸è¿”å›)ï¼›æ±‚æ‰€æœ‰è§£ä¿¡æ¯ï¼Œè®¾resultï¼Œè¿”å›å€¼voidã€‚
ç¬¬ä¸‰ç§ï¼Œè®¾ä¸ªå…¨å±€å˜é‡bestï¼Œè¿”å›å€¼æ˜¯voidã€‚

å›æº¯å…¶å®æ˜¯åŸºäºDFSçš„



1 å‡ºå£ã€‚ä¸€ä¸ªé€’å½’ç®—æ³•ä¸€å®šè¦æœ‰å‡ºå£ï¼Œå¦åˆ™å°±æ˜¯ä¸€ä¸ªæ­»å¾ªç¯äº†ã€‚ã€æŠŠå‡ºå£è¯­å¥æ”¾åœ¨é€’å½’å‡½æ•°çš„ç¬¬ä¸€è¡Œå°±è¡Œã€‘
2 é€’å½’å‡½æ•°çš„å‚æ•°ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œé€’å½’å‡½æ•°æ˜¯è¦å¸¦å‚æ•°çš„ï¼Œå› ä¸ºé€’å½’æ“ä½œéƒ½æ˜¯ç”¨æ¥å¤„ç†ä¸‹ä¸€æ¬¡çš„è¿‡ç¨‹ï¼Œå¦‚æœæ²¡æœ‰å‚æ•°çš„è¯ï¼Œé‚£ä¹ˆå°±å¾ˆéš¾ä»ä¸‹ä¸€æ¬¡çš„æ“ä½œå›æº¯åˆ°å½“å‰æ“ä½œäº†ã€‚
ã€ä¸ç ´åå½“å‰å‚æ•°çš„å€¼ï¼Œç›´æ¥æŠŠå½“å‰å€¼åŠ ä¸Šä¸€ä¸ªå€¼ã€‘ã€ç»“æœä¸€å®šæ˜¯è¦æœ‰ä¸€ä¸ªå…¨å±€å‚æ•°æ¥ä¿å­˜ã€‘
3 é€’å½’å‡½æ•°çš„å¤„ç†è¿‡ç¨‹ã€‚
ã€å¦‚æœå½“å‰é€’å½’è¿‡ç¨‹çš„å¤„ç†å‚æ•°ç¬¦åˆè¦æ±‚ï¼Œåˆ™æ‰§è¡Œç›¸å…³èµ‹å€¼æˆ–å…¶å®ƒæ“ä½œï¼Œç„¶åè½¬å…¥ä¸‹ä¸€æ¬¡é€’å½’ï¼Œå¦‚æœä¸‹ä¸€æ¬¡é€’å½’ä¸èƒ½æ‰¾åˆ°å‡ºå£ï¼Œ
åˆ™æŠŠä¹‹å‰ç›¸å…³èµ‹å€¼æˆ–å…¶å®ƒæ“ä½œé‡ç½®ä¸ºåˆå§‹çŠ¶æ€ã€‚ã€‘
4. å·²ç»æ‹¿è¿‡çš„æ•°ä¸å†æ‹¿ if(s.contains(num)){continue;}
5. éå†è¿‡å½“å‰èŠ‚ç‚¹åï¼Œä¸ºäº†å›æº¯åˆ°ä¸Šä¸€æ­¥ï¼Œè¦å»æ‰å·²ç»åŠ å…¥åˆ°ç»“æœlistä¸­çš„å½“å‰èŠ‚ç‚¹ã€‚

æ€è€ƒğŸ¤”ï¼š
åœ¨permutationå“ªä¸ªé¢˜ï¼Œåœ¨æ¯æ¬¡é‡Œé¢è¦ç¡®å®šè¿™ä¸€å±‚ï¼Œæˆ–è€…è¯´è¿™ä¸€æ¬¡å¯ä»¥éå†çš„ä¸ªæ•°
è€Œåœ¨subsetsé¢˜ä¸­ï¼Œæ¯ä¸€å±‚åªæœ‰é€‰ä¸­è¿™ä¸ªæˆ–è€…ä¸é€‰ä¸­è¿™ä¸ªç‚¹ä¸¤ç§å¯èƒ½ï¼Œæ‰€ä»¥æ²¡æœ‰forå¾ªç¯ã€‚ï¼Ÿ


ä»¥ä¸‹æ˜¯leetcodeé‡Œçš„ä¾‹é¢˜
39. Combination Sum
Solution:
from copy import deepcopy
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self.ans = []
        # if len(candidates)<=1:
        # candidates
        self.path = []
        candidates.sort()
        self.helper(candidates, target, 0)
        return self.ans
    
    def helper(self, candidates, target, level):
        if target==0:
            self.ans.append(deepcopy(self.path))
            return
        for i in range(level, len(candidates)):
            if target-candidates[i]<0:
                break
            self.path.append(candidates[i])
            self.helper(candidates, target-candidates[i], i)
            self.path.pop()

40. Combination Sum II
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        self.ans = []
        self.path = []
        candidates.sort()
        visited = [False]*len(candidates)
        self.helper(candidates, target, 0, visited)
        return self.ans
    
    def helper(self, candidates, target, level, visited):
        if target==0:
            self.ans.append(deepcopy(self.path))
            return
        for i in range(level, len(candidates)):
            if i>level and candidates[i]==candidates[i-1]:
                continue
            å…³é”®å°±æ˜¯åŒä¸€å±‚ä¸èƒ½ç”¨ä¸¤æ¬¡ï¼Œä½†æ˜¯ä¸‹ä¸€å±‚å¯ä»¥ç»§ç»­ç”¨
            if visited[i]:
                continue
            if target-candidates[i]<0:
                break
            self.path.append(candidates[i])
            visited[i] = True
            self.helper(candidates, target-candidates[i], i+1, visited)
            self.path.pop()
            visited[i] = False

79. Word Search
Solution:
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        rows, cols = len(board), len(board[0])
        # query = []
        self.ans = False
        for i in range(rows):
            for j in range(cols):
                if board[i][j]==word[0]:
                    if self.ans==True:
                        return True
                    visited = [[False]*cols for _ in range(rows)]
                    visited[i][j] = True
                    self.dfs(i, j, board, word[1:], visited)
        return self.ans
        
    def dfs(self, i, j, board, word, visited):
        if self.ans==True:
            return
        directions = [(1, 0), (0, 1), (0, -1), (-1, 0)]
        if not word:
            self.ans = True
            return
        for direction in directions:
            nx = i + direction[0]
            ny = j + direction[1]
            if 0<=nx<=len(board)-1 and 0<=ny<=len(board[0])-1 and not visited[nx][ny]:
                if board[nx][ny]==word[0]:
                    visited[nx][ny]=True
                    self.dfs(nx, ny, board, word[1:], visited)
                    visited[nx][ny]=False

46. Permutations
Solution:
def permute(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        if len(nums)<1:
            return []
        visited = [False]*len(nums)
        # visited[0] = True
        self.helper(nums, [], visited)
        return self.ans
    
    def helper(self, nums, path, visited):
        if len(path)==len(nums):
            self.ans.append(deepcopy(path))
            return
        for i in range(len(nums)):
            if not visited[i]:
                visited[i] = True
                self.helper(nums, path+[nums[i]], visited)
                visited[i] = False

47. Permutations II
Solution:
from copy import deepcopy
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        nums.sort()
        # print(nums)
        visited = [False]*len(nums)
        self.helper(nums, [], visited)
        return self.ans
    
    def helper(self, nums, path, visited):
        if len(path)==len(nums):
            self.ans.append(deepcopy(path))
            return
        # è‹¥å½“å‰å…ƒç´ æœªè¢«é€‰æ‹©ä¸”å‰ä¸€å…ƒç´ ä¸å½“å‰å…ƒç´ å€¼ç›¸ç­‰ä¹Ÿæœªè¢«é€‰æ‹©åˆ™è·³è¿‡ï¼Œè¿™ä¸€å¯èƒ½æƒ…å†µä¸å…ˆé€‰å°åºå·åé€‰å¤§åºå·çš„ç›¸åŒå…ƒç´ ç›¸åŒ
        for i in range(len(nums)):
            if visited[i]:
                continue
            elif i>0 and nums[i-1]==nums[i] and visited[i-1]:
                continue
            else:
                visited[i]=True
                self.helper(nums, path+[nums[i]], visited)
                visited[i]=False 

90. Subsets II
Solution:
(1)
ztçš„æ–¹æ³•ç¬¬ä¸€ä¸ªappendçš„æ˜¯æœ€é•¿çš„åºåˆ—ï¼Œç„¶åå†æ…¢æ…¢å»æ‰åã€‚
from copy import deepcopy
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        nums.sort()
        visited = [False]*len(nums)
        self.helper(nums, [], visited, 0)
        return self.ans
    
    def helper(self, nums, path, visited, level):
        if level==len(nums):
            self.ans.append(deepcopy(path))
            return
        # for i in range(len(nums)):
        #     if visited[i]:
        #         continue
        #     if i>0 and nums[i-1]==nums[i] and visited[i-1]:
        #         continue
        #     visited[i]=True
        #     self.helper(nums, path+[nums[i]], visited, level+1)
        #     visited[i]=False
        #     self.helper(nums, path, visited, level+1)
        self.helper(nums, path+[nums[level]], visited, level+1)
        while level+1<len(nums) and nums[level+1]==nums[level]:
            level += 1
        self.helper(nums, path, visited, level+1)
(2)
è¿™ä¸ªæ–¹æ³•æ˜¯ä»ã€ã€‘å¼€å§‹é‡Œé¢åŠ å…ƒç´ ï¼Œç†è®ºä¸Šè¿™ä¸ªæ›´å¿«
from copy import deepcopy
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        nums.sort()
        # visited = [False]*len(nums)
        self.helper(nums, [], 0)
        return self.ans
    
    def helper(self, nums, path, position):
        self.ans.append(deepcopy(path))
        for i in range(position, len(nums)):
            if i>position and nums[i]==nums[i-1]:
                continue
            self.helper(nums, path+[nums[i]], i+1)

78. Subsets
ï¼ˆ1ï¼‰
Solution:
from copy import deepcopy
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        if len(nums)==1:
            return []
        nums.sort()
        visited = [False]*(len(nums))
        self.helper(nums, [], visited, 0)
        return self.ans
        
    def helper(self, nums, path, visited, index):
        if index==len(nums):
            self.ans.append(deepcopy(path))
            return
        visited[index]=True
        self.helper(nums, path+[nums[index]], visited, index+1)
        visited[index]=False
        self.helper(nums, path, visited, index+1)
ï¼ˆ2ï¼‰
ç¬¬äºŒç§æ–¹æ³•æ˜¯æ¯æ¬¡é€’å½’åˆšå¼€å§‹å°±æŠŠpathç»™åŠ è¿›ç­”æ¡ˆä¸­ï¼Œè®°å½•ç”¨æ²¡ç”¨è¿‡çš„ç‚¹å°±è¡Œäº†ã€‚
from copy import deepcopy
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        if len(nums)<0:
            return []
        self.helper(nums, [], 0)
        return self.ans
        
    def helper(self, nums, path, index):
        self.ans.append(deepcopy(path))
        for i in range(index, len(nums)):
            self.helper(nums, path+[nums[i]], i+1)

22. Generate Parentheses
Solution:
from copy import deepcopy
class Solution:
    def generateParenthesis(self, n: int):
        """
        :param n: 
        :return: 
        """
        self.ans = []
        self.helper(n, n, "")
        return self.ans
    
    def helper(self, ll, rl, path):
        if ll==0 and rl==0:
            self.ans.append(deepcopy(path))
            return
        if ll==0:
            self.helper(ll, rl-1, path+")")
        elif rl==0:
            self.helper(ll-1, rl, path+"(")
        elif ll==rl:
            self.helper(ll-1, rl, path+"(")
        else:
            self.helper(ll-1, rl, path+"(")
            self.helper(ll, rl-1, path+")")

980. Unique Paths III (HARD)
Solution:
class Solution:
    def uniquePathsIII(self, grid) -> int:
        self.ans = 0
        rows = len(grid)
        cols = len(grid[0])

        steps = 1
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 0:
                    steps += 1
                if grid[row][col] == 1:
                    sx, sy = row, col

        visited = [[False] * cols for _ in range(rows)]
        visited[sx][sy] = True
        self.helper(0, steps, grid, sx, sy, visited)
        return self.ans

    def helper(self, cur, steps, grid, i, j, visited):
        if grid[i][j] == 2:
            if cur==steps:
                self.ans += 1
            return

        directions = [(1, 0), (0, 1), (0, -1), (-1, 0)]
        for direct in directions:
            nx = i + direct[0]
            ny = j + direct[1]
            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and visited[nx][ny] == False and grid[nx][ny]!=-1:
                visited[nx][ny] = True
                self.helper(cur+1, steps, grid, nx, ny, visited)
                visited[nx][ny] = False

